.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Das::ProServer::Authenticator::http 3pm"
.TH Bio::Das::ProServer::Authenticator::http 3pm "2009-10-20" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Das::ProServer::Authenticator::http \- authenticates DAS requests by issuing
requests to a remote authority
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$LastChangedRevision:\fR 558 $
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
To authenticate a request:
.PP
.Vb 5
\&  my $auth = Bio::Das::ProServer::Authenticator::http\->new({
\&    \*(Aqconfig\*(Aq => {
\&                 \*(Aqauthurl\*(Aq     => \*(Aqhttp://my.example.com/is_root?query=%token\*(Aq,
\&                },
\&  });
\&  
\&  my $allow = $auth\->authenticate({
\&    \*(Aqpeer_addr\*(Aq => $, # packed
\&    \*(Aqrequest\*(Aq   => $, # HTTP::Request object
\&    \*(Aqcgi\*(Aq       => $, # CGI object
\&    ...
\&  });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Authenticates \s-1DAS\s0 requests by connecting to a remote authentication \s-1HTTP\s0 server.
An authentication token is parsed from the \s-1DAS\s0 request. By default this should
be in an 'Authorization' header, but the authenticator can be configured to look
in a cookie, \s-1CGI\s0 parameter or a header with a different name.
.PP
The authentication token is referred to a remote server to ask a yes/no question
(e.g. \*(L"Is this user in a certain group of users?\*(R"). The server, for which the \s-1URL\s0
is configurable, should return a status code of either 200 (\s-1OK\s0) or a denial
response that will be forwarded to the client. For example if the remote wishes
to deny the request, it could respond with a status code of 403, textual content
for explanation and any necessary custom headers.
.PP
Authentication results are cached for 30 minutes in order to minimise the number
of requests issued to the remote server. Internal Server Error responses (code
500) are not cached.
.PP
This module may be easily overridden to parse the authentication token in
different ways.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "authenticate : Applies authentication to a request."
.IX Subsection "authenticate : Applies authentication to a request."
.Vb 2
\&  Requires: a hash reference containing details of the DAS request
\&  Returns:  either nothing (allow) or a HTTP::Response (deny)
\&
\&  my $allow = $oAuth\->authenticate({
\&    \*(Aqpeer_addr\*(Aq => $, # packed
\&    \*(Aqrequest\*(Aq   => $, # HTTP::Request object
\&    \*(Aqcgi\*(Aq       => $, # CGI object
\&    ...
\&  });
\&
\&  The method follows this procedure:
\&  1. Parse an authentication token from the DAS request (parse_token method).
\&  2. Check for cached results for this token.
\&  3. If not found, query the remote server.
\&  4. Store the response in the cache, unless it is a server error (500)
\&  4. If the response code is 200 allow the request, otherwise deny.
.Ve
.SS "parse_token : Parses the \s-1DAS\s0 request to extract an authentication token"
.IX Subsection "parse_token : Parses the DAS request to extract an authentication token"
.Vb 2
\&  Requires: a hash reference containing details of the DAS request
\&  Returns:  a string authentication token
\&
\&  my $token = $oAuth\->parse_token({
\&    \*(Aqpeer_addr\*(Aq => $, # packed
\&    \*(Aqrequest\*(Aq   => $, # HTTP::Request object
\&    \*(Aqcgi\*(Aq       => $, # CGI object
\&    ...
\&  });
\&
\&  Depending on configuration, the authentication token is extracted from:
\&  1. a named cookie
\&  2. a named CGI parameter
\&  3. a named request header
\&  4. the \*(AqAuthorization\*(Aq request header (default)
.Ve
.PP
This method may be overridden to extract the token in a different manner.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.Vb 4
\&  my $auth = Bio::Das::ProServer::Authenticator::http\->new({
\&    ...
\&    \*(Aqdebug\*(Aq  => 1,
\&  });
.Ve
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
The \s-1URL\s0 to use for remote authentication is configured in the source \s-1INI\s0 section.
Any instances of \*(L"%token\*(R" will be replaced by the value of the authentication
token parsed from the \s-1DAS\s0 request.
.PP
.Vb 7
\&  [mysource]
\&  authenticator = http
\&  authurl       = http://auth.example.com/is_allowed?query=%token
\&  ; Optionally define location of auth token (default is \*(AqAuthorization\*(Aq header)
\&  ; authcookie    = cookiename
\&  ; authheader    = headername
\&  ; authparam     = cgiparamname
.Ve
.PP
An \s-1HTTP\s0 proxy may be specified in the shell environment.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.IP "Carp" 4
.IX Item "Carp"
.PD 0
.IP "Bio::Das::ProServer::Authenticator" 4
.IX Item "Bio::Das::ProServer::Authenticator"
.IP "LWP::UserAgent" 4
.IX Item "LWP::UserAgent"
.PD
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
This authenticator implementation may only be used to ask yes/no questions,
such as \*(L"does this token identify a user with sufficient privileges?\*(R". Questions
such as \*(L"which user does this token identify?\*(R" have additional security
implications and are therefore not supported.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Jenkinson <andy.jenkinson@ebi.ac.uk>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2008 EMBL-EBI
