.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.09)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Das::ProServer::SourceAdaptor 3pm"
.TH Bio::Das::ProServer::SourceAdaptor 3pm "2009-12-03" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Das::ProServer::SourceAdaptor \- base class for sources
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$Revision:\fR 607 $
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A base class implementing stubs for all SourceAdaptors.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SourceAdaptor.pm generates \s-1XML\s0 and manages callouts for \s-1DAS\s0 request
handling.
.PP
If you're extending ProServer, this class is probably what you need to
inherit. The build_* methods are probably the ones you need to
extend. \fIbuild_features()\fR in particular.
.SH "AUTHOR"
.IX Header "AUTHOR"
Roger Pettett <rmp@sanger.ac.uk>
.PP
Andy Jenkinson <andy.jenkinson@ebi.ac.uk>
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new \- Constructor"
.IX Subsection "new - Constructor"
.Vb 9
\&  my $oSourceAdaptor = Bio::Das::ProServer::SourceAdaptor::<implementation>\->new({
\&    \*(Aqdsn\*(Aq      => q(),
\&    \*(Aqport\*(Aq     => q(),
\&    \*(Aqhostname\*(Aq => q(),
\&    \*(Aqprotocol\*(Aq => q(),
\&    \*(Aqbaseuri\*(Aq  => q(),
\&    \*(Aqconfig\*(Aq   => q(),
\&    \*(Aqdebug\*(Aq    => 1,
\&  });
\&
\&  Generally this would only be invoked on a subclass
.Ve
.SS "init \- Post-construction initialisation, passed the first argument to \fInew()\fP"
.IX Subsection "init - Post-construction initialisation, passed the first argument to new()"
.Vb 1
\&  $oSourceAdaptor\->init();
.Ve
.SS "length \- Returns the segment-length given a segment"
.IX Subsection "length - Returns the segment-length given a segment"
.Vb 1
\&  my $sSegmentLength = $oSourceAdaptor\->length(\*(AqDYNA_CHICK\*(Aq);
\&  
\&  By default returns 0
.Ve
.SS "mapmaster \- Mapmaster for this source."
.IX Subsection "mapmaster - Mapmaster for this source."
.Vb 1
\&  my $sMapMaster = $oSourceAdaptor\->mapmaster();
\&  
\&  By default returns configuration \*(Aqmapmaster\*(Aq setting
.Ve
.SS "description \- Description for this source."
.IX Subsection "description - Description for this source."
.Vb 1
\&  my $sDescription = $oSourceAdaptor\->description();
\&  
\&  By default returns configuration \*(Aqdescription\*(Aq setting or $self\->title
.Ve
.SS "doc_href \- Location of a homepage for this source."
.IX Subsection "doc_href - Location of a homepage for this source."
.Vb 1
\&  my $sDocHref = $oSourceAdaptor\->doc_href();
\&  
\&  By default returns configuration \*(Aqdoc_href\*(Aq setting
.Ve
.SS "title \- Short title for this source."
.IX Subsection "title - Short title for this source."
.Vb 1
\&  my $title = $oSourceAdaptor\->title();
\&  
\&  By default returns configuration \*(Aqtitle\*(Aq setting or $self\->source_uri
.Ve
.SS "source_uri \- \s-1URI\s0 for all versions of a source."
.IX Subsection "source_uri - URI for all versions of a source."
.Vb 1
\&  my $uriS = $oSourceAdaptor\->source_uri();
\&  
\&  By default returns configuration \*(Aqsource_uri\*(Aq setting or $self\->dsn
.Ve
.SS "version_uri \- \s-1URI\s0 for a specific version of a source."
.IX Subsection "version_uri - URI for a specific version of a source."
.Vb 1
\&  my $uriV = $oSourceAdaptor\->version_uri();
\&  
\&  By default returns configuration \*(Aqversion_uri\*(Aq setting or $self\->source_uri
.Ve
.SS "maintainer \- Contact email for this source."
.IX Subsection "maintainer - Contact email for this source."
.Vb 1
\&  my $email = $oSourceAdaptor\->maintainer();
\&  
\&  By default returns configuration \*(Aqmaintainer\*(Aq setting, server setting or an empty string
.Ve
.SS "strict_boundaries \- Whether to return error segments for out-of-range queries"
.IX Subsection "strict_boundaries - Whether to return error segments for out-of-range queries"
.Vb 1
\&  my $strict = $oSourceAdaptor\->strict_boundaries(); # boolean
\&  
\&  By default returns configuration \*(Aqstrict_boundaries\*(Aq setting, server setting or nothing (false)
.Ve
.SS "build_features \- (subclasses only) Fetch feature data"
.IX Subsection "build_features - (subclasses only) Fetch feature data"
This call is made by \fIdas_features()\fR. It is passed one of:
.PP
.Vb 6
\& { \*(Aqsegment\*(Aq    => $,
\&   \*(Aqstart\*(Aq      => $,
\&   \*(Aqend\*(Aq        => $,
\&   \*(Aqtypes\*(Aq      => [$,$,...],
\&   \*(Aqcategories\*(Aq => [$,$,...],
\&   \*(Aqmaxbins\*(Aq    => $ }        # if support is indicated by the \*(Aqmaxbins\*(Aq capability
.Ve
.PP
\&\s-1OR\s0, if support is indicated by the 'feature\-by\-id' capability:
.PP
.Vb 4
\& { \*(Aqfeature_id\*(Aq => $,
\&   \*(Aqtypes\*(Aq      => [$,$,...],
\&   \*(Aqcategories\*(Aq => [$,$,...],
\&   \*(Aqmaxbins\*(Aq    => $ }        # if support is indicated by the \*(Aqmaxbins\*(Aq capability
.Ve
.PP
When running in legacy mode, it may also be passed:
.PP
.Vb 4
\& { \*(Aqgroup_id\*(Aq   => $,
\&   \*(Aqtypes\*(Aq      => [$,$,...],
\&   \*(Aqcategories\*(Aq => [$,$,...],
\&   \*(Aqmaxbins\*(Aq    => $ }        # if support is indicated by the \*(Aqmaxbins\*(Aq capability
.Ve
.PP
The 'types' and 'categories' parameters are filters. They do not need to be
honoured as the das_features method will do this for you. They are included in
case you wish to use them to improve performance.
.PP
The method must return a reference to an array of hash references, i.e.
 [{},{}...{}]
.PP
Each hash returned represents a single feature and should contain a
subset of the following keys and types. For scalar types (i.e. numbers
and strings) refer to the specification on biodas.org.
.PP
.Vb 10
\& segment                       => $               # segment ID (if not provided)
\& id       || feature_id        => $               # feature ID
\& label    || feature_label     => $               # feature text label
\& start                         => $               # feature start position
\& end                           => $               # feature end position
\& ori                           => $               # feature strand
\& phase                         => $               # feature phase
\& type                          => $               # feature type ID
\& type_cvid                     => $               # feature type controlled vocabulary ID
\& typetxt                       => $               # feature type text label
\& typecategory || type_category => $               # feature type category
\& typesubparts                  => $               # feature has subparts
\& typesuperparts                => $               # feature has superparts
\& typereference                 => $               # feature is reference
\& method                        => $               # annotation method ID
\& method_cvid                   => $               # annotation method controlled vocabulary ID
\& method_label                  => $               # annotation method text label
\& score                         => $               # annotation score
\& note                          => $ or [$,$,$...] # feature text note
\& ##########################################################################
\& # For one or more links:
\& link                          => $ or [$,$,$...] # feature link href
\& linktxt                       => $ or [$,$,$...] # feature link label
\& # For hash\-based links:
\& link                          => {
\&                                   $ => $,        # href => label
\&                                   ...
\&                                  }
\& ###############################################################################
\& # For a single target:
\& target_id                     => $               # target ID
\& target_start                  => $               # target start position
\& target_stop                   => $               # target end position
\& targettxt                     => $               # target text label
\& # For multiple targets:
\& target                        => scalar or [{
\&                                              id        => $,
\&                                              start     => $,
\&                                              stop      => $,
\&                                              targettxt => $,
\&                                             },{}...]
\& ###############################################################################
\& # For hierarchical relationships:
\& parent                        => $ or [$,$,$...] # parent feature IDs
\& part                          => $ or [$,$,$...] # child feature IDs
\& ###############################################################################
.Ve
.PP
When running in legacy mode, the following may also be included:
.PP
.Vb 10
\& # For a single group:
\& group_id                      => $               # feature group ID
\& grouplabel                    => $               # feature group text label
\& grouptype                     => $               # feature group type ID
\& groupnote                     => $               # feature group text note
\& grouplink                     => $               # feature group ID
\& grouplinktxt                  => $               # feature group ID
\& # For multiple groups:
\& group                         => [{
\&                                    grouplabel   => $
\&                                    grouptype    => $
\&                                    groupnote    => $
\&                                    grouplink    => $
\&                                    grouplinktxt => $
\&                                    note         => $ or [$,$,$...]
\&                                    target       => [{
\&                                                      id        => $
\&                                                      start     => $
\&                                                      stop      => $
\&                                                      targettxt => $
\&                                                     }],
\&                                   }, {}...]
\& ###############################################################################
.Ve
.SS "sequence \- (Subclasses only) fetch sequence data"
.IX Subsection "sequence - (Subclasses only) fetch sequence data"
This call is made by \fIdas_sequence()\fR. It is passed:
.PP
.Vb 1
\& { \*(Aqsegment\*(Aq    => $, \*(Aqstart\*(Aq => $, \*(Aqend\*(Aq => $ }
.Ve
.PP
It is expected to return a hash reference:
.PP
.Vb 5
\& {
\&  seq     => $,
\&  version => $, # can also be specified with the segment_version method
\&  label   => $, # optional human readable label
\& }
.Ve
.PP
For details of the data constraints refer to the specification on biodas.org.
.SS "build_types \- (Subclasses only) fetch type data"
.IX Subsection "build_types - (Subclasses only) fetch type data"
This call is made by \fIdas_types()\fR. If no specific segments are requested by the
client, it is passed no arguments. Otherwise it is passed:
.PP
.Vb 1
\& { \*(Aqsegment\*(Aq    => $, \*(Aqstart\*(Aq => $, \*(Aqend\*(Aq => $ }
.Ve
.PP
It is expected to return a reference to an array of hash references, i.e.
 [{},{}...{}]
.PP
Each hash returned represents a single type and should contain a
subset of the following keys and values. For scalar types (i.e. numbers
and strings) refer to the specification on biodas.org.
.PP
.Vb 5
\& type                                       => $ # required
\& type_cvid || c_ontology                    => $
\& typetxt   || description                   => $
\& category  || typecategory || type_category => $
\& count                                      => $
.Ve
.SS "build_entry_points \- (Subclasses only) fetch entry_points data"
.IX Subsection "build_entry_points - (Subclasses only) fetch entry_points data"
This call is made by \fIdas_entry_points()\fR. It is not passed any args
.PP
and is expected to return a reference to an array of hash references, i.e.
 [{},{}...{}]
.PP
Each hash returned represents a single entry_point and should contain a
subset of the following keys and values. For scalar types (i.e. numbers
and strings) refer to the specification on biodas.org.
.PP
.Vb 6
\& segment  => $
\& length   => $
\& subparts => $
\& start    => $
\& stop     => $
\& ori      => $
.Ve
.SS "build_alignment \- (Subclasses only) fetch alignment data"
.IX Subsection "build_alignment - (Subclasses only) fetch alignment data"
This call is made by \fIdas_alignment()\fR. It is passed these arguments:
.PP
.Vb 6
\& (
\&  $,        # alignment ID
\&  $,        # number of rows
\&  [ $, $ ], # subjects
\&  $         # subject coordinate system
\& )
.Ve
.PP
Note that all arguments are optional, but either the alignment \s-1ID\s0 or at least
one subject \s-1ID\s0 will be provided.
.PP
It is expected to return an array reference of alignment hash references:
.PP
.Vb 10
\& [
\&  {
\&   name     => $,
\&   type     => $,
\&   max      => $,
\&   position => $,
\&   alignObj => [
\&                {
\&                 id              => $, # internal object ID
\&                 version         => $,
\&                 type            => $,
\&                 dbSource        => $,
\&                 dbVersion       => $,
\&                 dbAccession     => $,
\&                 dbCoordSys      => $,
\&                 sequence        => $,
\&                 aliObjectDetail => [
\&                                     {
\&                                      property => $,
\&                                      value    => $,
\&                                      dbSource => $,
\&                                     },
\&                                    ],
\&                },
\&               ],
\&   scores   => [
\&                {
\&                 method => $,
\&                 score  => $,
\&                },
\&               ],
\&   blocks   => [
\&                {
\&                 blockOrder => $,
\&                 blockScore => $,
\&                 segments   => [
\&                                {
\&                                 id          => $, # internal object ID
\&                                 start       => $,
\&                                 end         => $,
\&                                 orientation => $, # + / \- / undef
\&                                 cigar       => $,
\&                                },
\&                               ],
\&               ],
\&   geo3D    => [
\&                {
\&                 id
\&                 vector => {
\&                            x => $,
\&                            y => $,
\&                            z => $,
\&                           },
\&                 matrix => [
\&                            [$,$,$], # mat11, mat12, mat13
\&                            [$,$,$], # mat21, mat22, mat23
\&                            [$,$,$], # mat31, mat32, mat33
\&                           ],
\&                },
\&               ],
.Ve
.SS "build_interaction \- (Subclasses only) fetch interaction data"
.IX Subsection "build_interaction - (Subclasses only) fetch interaction data"
This call is made by \fIdas_interaction()\fR. It is passed this structure:
.PP
.Vb 9
\& # For request:
\& # /interaction?interactor=$;interactor=$;detail=property:$;detail=property:$,value:$
\& {
\&  interactors => [$, $, ..],
\&  details     => {
\&                  $ => undef, # property exists
\&                  $ => $,     # property has a certain value
\&                 },
\& }
.Ve
.PP
It is expected to return a hash reference of interactions and interactors where 
all the requested interactors are part of the interaction:
.PP
.Vb 10
\& {
\&  interactors => [
\&                  {
\&                   id            => $,
\&                   label || name => $,
\&                   dbSource      => $,
\&                   dbSourceCvId  => $, # controlled vocabulary ID
\&                   dbVersion     => $,
\&                   dbAccession   => $,
\&                   dbCoordSys    => $, # co\-ordinate system
\&                   sequence      => $,
\&                   details       => [
\&                                     {
\&                                      property        => $,
\&                                      value           => $,
\&                                      propertyCvId    => $,
\&                                      valueCvId       => $,
\&                                      start           => $, 
\&                                      end             => $,
\&                                      startStatus     => $,
\&                                      endStatus       => $,
\&                                      startStatusCvId => $,
\&                                      endStatusCvId   => $,
\&                                     },
\&                                     ..
\&                                    ],
\&                  },
\&                  ..
\&                 ],
\&  interactions => [
\&                   {
\&                    label || name => $,
\&                    dbSource      => $,
\&                    dbSourceCvId  => $,
\&                    dbVersion     => $,
\&                    dbAccession   => $,
\&                    details       => [
\&                                      {
\&                                       property     => $,
\&                                       value        => $,
\&                                       propertyCvId => $,
\&                                       valueCvId    => $,
\&                                      },
\&                                      ..
\&                                     ],
\&                    participants  => [
\&                                      {
\&                                       id      => $,
\&                                       details => [
\&                                                   {
\&                                                    property        => $,
\&                                                    value           => $,
\&                                                    propertyCvId    => $,
\&                                                    valueCvId       => $,
\&                                                    start           => $,
\&                                                    end             => $,
\&                                                    startStatus     => $,
\&                                                    endStatus       => $,
\&                                                    startStatusCvId => $,
\&                                                    endStatusCvId   => $,
\&                                                   },
\&                                                   ..
\&                                                  ],
\&                                      },
\&                                      ..
\&                                     ],
\&                   },
\&                   ..
\&                  ],
\& }
.Ve
.SS "build_volmap \- (Subclasses only) fetch volume map data"
.IX Subsection "build_volmap - (Subclasses only) fetch volume map data"
This call is made by \fIdas_volmap()\fR. It is passed a single 'query' argument.
.PP
It is expected to return a hash reference for a single volume map:
.PP
.Vb 9
\& {
\&  id      => $,
\&  class   => $,
\&  type    => $,
\&  version => $,
\&  link    => $,                  # href for data
\&  linktxt => $,                  # text
\&  note    => $  OR  [ $, $, .. ]
\& }
.Ve
.SS "init_segments \- hook for optimising results to be returned."
.IX Subsection "init_segments - hook for optimising results to be returned."
.Vb 3
\&  By default \- do nothing
\&  Not necessary for most circumstances, but useful for deciding on what sort
\&  of coordinate system you return the results if more than one type is available.
\&
\&  $self\->init_segments() is called inside das_features() before build_features().
.Ve
.SS "known_segments \- returns a list of valid segments that this adaptor knows about"
.IX Subsection "known_segments - returns a list of valid segments that this adaptor knows about"
.Vb 1
\&  my @aSegmentNames = $oSourceAdaptor\->known_segments();
.Ve
.SS "segment_version \- gives the version of a segment (\s-1MD5\s0 under certain circumstances) given a segment name"
.IX Subsection "segment_version - gives the version of a segment (MD5 under certain circumstances) given a segment name"
.Vb 1
\&  my $sVersion = $oSourceAdaptor\->segment_version($sSegment);
.Ve
.SS "dsn \- get accessor for this sourceadaptor's dsn"
.IX Subsection "dsn - get accessor for this sourceadaptor's dsn"
.Vb 1
\&  my $sDSN = $oSourceAdaptor\->dsn();
.Ve
.SS "dsnversion \- get accessor for this sourceadaptor's dsn version"
.IX Subsection "dsnversion - get accessor for this sourceadaptor's dsn version"
.Vb 1
\&  my $sDSNVersion = $oSourceAdaptor\->dsnversion();
\&  
\&  By default returns $self\->{\*(Aqdsnversion\*(Aq}, configuration \*(Aqdsnversion\*(Aq setting or \*(Aq1.0\*(Aq
.Ve
.SS "dsncreated \- get accessor for this sourceadaptor's update time (variable format)"
.IX Subsection "dsncreated - get accessor for this sourceadaptor's update time (variable format)"
.Vb 6
\&  # e.g. \*(Aq2007\-09\-20T15:26:23Z\*(Aq      \-\- ISO 8601, Coordinated Universal Time
\&  # e.g. \*(Aq2007\-09\-20T16:26:23+01:00\*(Aq \-\- ISO 8601, British Summer Time
\&  # e.g. \*(Aq2007\-09\-20 07:26:23 \-08\*(Aq   \-\- indicating Pacific Standard Time
\&  # e.g. 1190301983                  \-\- UNIX
\&  # e.g. \*(Aq2007\-09\-20\*(Aq
\&  my $sDSNCreated = $oSourceAdaptor\->dsncreated(); 
\&  
\&  By default tries and returns the following:
\&    1. $self\->{\*(Aqdsncreated\*(Aq}
\&    2. configuration \*(Aqdsncreated\*(Aq setting
\&    3. adaptor\*(Aqs \*(Aqlast_modified\*(Aq method (if it exists)
\&    4. zero (epoch)
.Ve
.SS "dsncreated_unix \- this sourceadaptor's update time, in \s-1UNIX\s0 format"
.IX Subsection "dsncreated_unix - this sourceadaptor's update time, in UNIX format"
.Vb 2
\&  # e.g. 1190301983
\&  my $sDSNCreated = $oSourceAdaptor\->dsncreated_unix();
.Ve
.SS "dsncreated_iso \- this sourceadaptor's update time, in \s-1ISO\s0 8601 format"
.IX Subsection "dsncreated_iso - this sourceadaptor's update time, in ISO 8601 format"
.Vb 2
\&  # e.g. \*(Aq2007\-09\-20T15:26:23Z\*(Aq
\&  my $sDSNCreated = $oSourceAdaptor\->dsncreated_iso();
.Ve
.SS "coordinates \- Returns this sourceadaptor's supported coordinate systems"
.IX Subsection "coordinates - Returns this sourceadaptor's supported coordinate systems"
.Vb 1
\&  my $hCoords = $oSourceAdaptor\->coordinates();
\&  
\&  Hash contains a key\-value pair for each coordinate system, the key being
\&  either the URI or description, and the value being a suitable test range.
\&  
\&  By default returns an empty hash reference
.Ve
.ie n .SS "_coordinates : Returns this sourceadaptor's supported coordinate systems in ""full"" format"
.el .SS "_coordinates : Returns this sourceadaptor's supported coordinate systems in ``full'' format"
.IX Subsection "_coordinates : Returns this sourceadaptor's supported coordinate systems in full format"
.Vb 1
\&  my $aCoords = $oSourceAdaptor\->_coordinates();
\&  
\&  Returns the fully\-annotated co\-ordinate systems this adaptor supports, as an
\&  array or array reference (depending on context):
\&    [
\&     {
\&      \*(Aqdescription\*(Aq => \*(AqNCBI_36,Chromosome,Homo sapiens\*(Aq,
\&      \*(Aquri\*(Aq         => \*(Aqhttp://www.dasregistry.org/dasregistry/coordsys/CS_DS40\*(Aq,
\&      \*(Aqtaxid\*(Aq       => \*(Aq9606\*(Aq,
\&      \*(Aqauthority\*(Aq   => \*(AqNCBI\*(Aq,
\&      \*(Aqsource\*(Aq      => \*(AqChromosome\*(Aq,
\&      \*(Aqversion\*(Aq     => \*(Aq36\*(Aq,
\&      \*(Aqtest_range\*(Aq  => \*(Aq1:11000000,12000000\*(Aq,
\&     },
\&     {
\&      ...
\&     },
\&    ]
\&  
\&  The co\-ordinate system details are read in from disk by Bio::Das::ProServer.
\&  By default returns an empty array.
\&
\&  DO NOT OVERRIDE THIS METHOD IN SUBCLASSES.
.Ve
.SS "capabilities \- Returns this sourceadaptor's supported capabilities"
.IX Subsection "capabilities - Returns this sourceadaptor's supported capabilities"
.Vb 1
\&  my $hCapabilities = $oSourceAdaptor\->capabilities();
\&  
\&  Hash contains a key\-value pair for each command, the key being the command
\&  name, and the value being the implementation version.
\&  
\&  By default returns an empty hash.
.Ve
.SS "_capabilities \- Returns this sourceadaptor's supported capabilities, as rationalised by ProServer"
.IX Subsection "_capabilities - Returns this sourceadaptor's supported capabilities, as rationalised by ProServer"
.Vb 1
\&  my $hCapabilities = $oSourceAdaptor\->_capabilities();
\&  
\&  Hash contains a key\-value pair for each command, the key being the command
\&  name, and the value being the implementation version.
\&  
\&  By default returns an empty hash.
\&
\&  DO NOT OVERRIDE THIS METHOD IN SUBCLASSES.
.Ve
.SS "properties \- Returns custom properties for this sourceadaptor"
.IX Subsection "properties - Returns custom properties for this sourceadaptor"
.Vb 1
\&  my $hProps = $oSourceAdaptor\->properties();
\&  
\&  Hash contains key\-scalar or key\-array pairs for custom properties.
\&  
\&  By default returns an empty hash reference
.Ve
.SS "start \- get accessor for segment start given a segment"
.IX Subsection "start - get accessor for segment start given a segment"
.Vb 1
\&  my $sStart = $oSourceAdaptor\->start(\*(AqDYNA_CHICK\*(Aq);
\&
\&  By default returns 1
.Ve
.SS "end \- get accessor for segment end given a segment"
.IX Subsection "end - get accessor for segment end given a segment"
.Vb 1
\&  my $sEnd = $oSourceAdaptor\->end(\*(AqDYNA_CHICK\*(Aq);
\&  
\&  By default returns $self\->length
.Ve
.SS "server_url \- Get the \s-1URL\s0 for the server (not including the /das)"
.IX Subsection "server_url - Get the URL for the server (not including the /das)"
.Vb 1
\&  my $sUrl = $oSourceAdaptor\->server_url();
.Ve
.SS "source_url \- Get the full \s-1URL\s0 for the source"
.IX Subsection "source_url - Get the full URL for the source"
.Vb 1
\&  my $sUrl = $oSourceAdaptor\->source_url();
.Ve
.SS "hydra \- Get the relevant B::D::PS::SourceHydra::<...> configured for this adaptor, if there is one"
.IX Subsection "hydra - Get the relevant B::D::PS::SourceHydra::<...> configured for this adaptor, if there is one"
.Vb 1
\&  my $oHydra = $oSourceAdaptor\->hydra();
.Ve
.SS "transport \- Build the relevant B::D::PS::SA::Transport::<...> configured for this adaptor"
.IX Subsection "transport - Build the relevant B::D::PS::SA::Transport::<...> configured for this adaptor"
.Vb 1
\&  my $oTransport = $oSourceAdaptor\->transport();
\&  
\&  OR
\&  
\&  my $oTransport1 = $oSourceAdaptor\->transport(\*(Aqfoo\*(Aq);
\&  my $oTransport2 = $oSourceAdaptor\->transport(\*(Aqbar\*(Aq);
.Ve
.SS "authenticator : Build the B::D::PS::Authenticator::<...> configured for this adaptor"
.IX Subsection "authenticator : Build the B::D::PS::Authenticator::<...> configured for this adaptor"
.Vb 1
\&  my $oAuthenticator = $oSourceAdaptor\->authenticator();
\&
\&  Authenticators are built only if explicitly configured in the INI file, e.g.:
\&  [mysource]
\&  state         = on
\&  adaptor       = simple
\&  authenticator = ip
\&  
\&  See L<Bio::Das::ProServer::Authenticator> for more details.
.Ve
.SS "config \- get/set config settings for this adaptor"
.IX Subsection "config - get/set config settings for this adaptor"
.Vb 1
\&  $oSourceAdaptor\->config($oConfig);
\&
\&  my $oConfig = $oSourceAdaptor\->config();
.Ve
.SS "implements \- helper to determine if an adaptor implements a request based on its capabilities"
.IX Subsection "implements - helper to determine if an adaptor implements a request based on its capabilities"
.Vb 1
\&  my $bIsImplemented = $oSourceAdaptor\->implements($sDASCall); # e.g. $sDASCall = \*(Aqsequence\*(Aq
.Ve
.SS "das_capabilities \- DAS-response capabilities header support"
.IX Subsection "das_capabilities - DAS-response capabilities header support"
.Vb 1
\&  my $sHTTPHeader = $oSourceAdaptor\->das_capabilities();
.Ve
.SS "unknown_segment \- DAS-response unknown/error segment error response"
.IX Subsection "unknown_segment - DAS-response unknown/error segment error response"
.Vb 1
\&  my $sXMLResponse = $sa\->unknown_segment();
\&
\&  Reference sources (i.e. those implementing the \*(Aqsequence\*(Aq command) will return an <ERRORSEGMENT> element.
\&  Annotation sources will return an <UNKNOWNSEGMENT> element.
.Ve
.SS "error_segment \- DAS-response error segment error response"
.IX Subsection "error_segment - DAS-response error segment error response"
.Vb 1
\&  my $sXMLResponse = $sa\->error_segment();
\&
\&  Returns an <ERRORSEGMENT> element.
.Ve
.SS "error_feature \- DAS-response unknown feature error"
.IX Subsection "error_feature - DAS-response unknown feature error"
.Vb 1
\&  my $sXMLResponse = $sa\->error_feature();
.Ve
.SS "das_features \- DAS-response for 'features' request"
.IX Subsection "das_features - DAS-response for 'features' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_features();
\&
\&  See the build_features method for details of custom implementations.
.Ve
.SS "das_sequence \- DAS-response for sequence request"
.IX Subsection "das_sequence - DAS-response for sequence request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_sequence();
\&
\&  See the sequence method for details of custom implementations.
.Ve
.SS "das_types \- DAS-response for 'types' request"
.IX Subsection "das_types - DAS-response for 'types' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_types();
\&
\&  See the build_types method for details of custom implementations.
.Ve
.SS "das_entry_points \- DAS-response for 'entry_points' request"
.IX Subsection "das_entry_points - DAS-response for 'entry_points' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_entry_points();
\&
\&  See the build_entry_points method for details of custom implementations.
.Ve
.SS "das_interaction \- DAS-response for 'interaction' request"
.IX Subsection "das_interaction - DAS-response for 'interaction' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_interaction();
\&
\&  See the build_interaction method for details of custom implementations.
.Ve
.SS "das_volmap \- DAS-response for 'volmap' request"
.IX Subsection "das_volmap - DAS-response for 'volmap' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_volmap();
\&
\&  See the build_volmap method for details of custom implementations.
.Ve
.SS "das_stylesheet \- DAS-response for 'stylesheet' request"
.IX Subsection "das_stylesheet - DAS-response for 'stylesheet' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_stylesheet();
\&
\&  By default will use (in order of preference):
\&    the "stylesheet" INI property (inline XML)
\&    the "stylesheetfile" INI property (XML file location)
\&    the "stylesheetfile" INI property, prepended with the "styleshome" property
\&    a default stylesheet
.Ve
.SS "das_sourcedata \- DAS-response for 'sources' request"
.IX Subsection "das_sourcedata - DAS-response for 'sources' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_sourcedata();
\&
\&  Provides information about the DAS source for use in the sources command,
\&  such as title, description, coordinates and capabilities.
.Ve
.SS "das_homepage \- DAS-response (non-standard) for 'homepage' or blank request"
.IX Subsection "das_homepage - DAS-response (non-standard) for 'homepage' or blank request"
.Vb 1
\&  my $sHTMLResponse = $sa\->das_homepage();
\&
\&  By default will use (in order of preference):
\&    the "homepage" INI property (inline HTML)
\&    the "homepagefile" INI property (HTML file location)
\&    a default homepage
.Ve
.SS "das_dsn \- DAS-response (non-standard) for 'dsn' request"
.IX Subsection "das_dsn - DAS-response (non-standard) for 'dsn' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_dsn();
.Ve
.SS "das_xsl \- DAS-response (non-standard) for 'xsl' request"
.IX Subsection "das_xsl - DAS-response (non-standard) for 'xsl' request"
.Vb 1
\&  my $sXSLResponse = $sa\->das_xsl();
.Ve
.SS "das_alignment \- DAS-response for 'alignment' request"
.IX Subsection "das_alignment - DAS-response for 'alignment' request"
.Vb 1
\&  my $sXMLResponse = $sa\->das_alignment();
\&
\&  See the build_alignment method for details of custom implementations.
\&
\&  Example Response:
.Ve
.PP
<alignment>
  <alignObject>
    <alignObjectDetail />
    <sequence />
  </alignObject>
  <score/>
  <block>
    <segment>
      <cigar />
    </segment>
  </block>
  <geo3D>
    <vector />
    <matrix mat11=\*(L"float\*(R" mat12=\*(L"float\*(R" mat13=\*(L"float\*(R"
            mat21=\*(L"float\*(R" mat22=\*(L"float\*(R" mat23=\*(L"float\*(R"
            mat31=\*(L"float\*(R" mat32=\*(L"float\*(R" mat33=\*(L"float\*(R" />
  </geo3D>	
</alignment>
.SS "_gen_align_object_response"
.IX Subsection "_gen_align_object_response"
.Vb 4
\& Title    : _gen_align_object_response
\& Function : Formats alignment object into dasalignment xml
\& Args     : align data structure
\& Returns  : Das Response string encapuslating aliObject
.Ve
.SS "_gen_align_score_response"
.IX Subsection "_gen_align_score_response"
.Vb 4
\& Title   : _gen_align_score_response
\& Function: Formats input score data structure into dasalignment xml
\& Args    : score data structure
\& Returns : Das Response string from alignment score
.Ve
.SS "_gen_align_block_response"
.IX Subsection "_gen_align_block_response"
.Vb 5
\& Title   : _gen_align_block_response
\& Function: Formats an input block data structure into 
\&         : dasalignment xml
\& Args    : block data structure
\& Returns : Das Response string from alignmentblock
.Ve
.SS "_gen_align_geo3d_response"
.IX Subsection "_gen_align_geo3d_response"
.Vb 4
\&  Title    : genAlignGeo3d
\&  Function : Formats geo3d data structure into alignment matrix xml
\&  Args     : data structure containing the vector and matrix
\&  Returns  : String containing the DAS response xml
.Ve
.SS "das_structure"
.IX Subsection "das_structure"
.Vb 8
\& Title    : das_structure
\& Function : This produces the das repsonse for a pdb structure
\& Args     : query options.  Currently, this will that query, chain and modelnumber.
\&          : The only part of the specification that this does not adhere to is the range argument. 
\&          : However, I think this argument is a potential can of worms!
\& returns  : string containing Das repsonse for the pdb structure
\& comment  : See http://www.efamily.org.uk/xml/das/documentation/structure.shtml for more information 
\&          : on the das structure specification.
\&
\& Example Response:
\&<object dbAccessionId="1A4A" intObjectId="1A4A" objectVersion="29\-APR\-98" type="protein structure" dbSource="PDB" dbVersion="20040621" dbCoordSys="PDBresnum" />
\&<chain id="A" SwissprotId="null">
\&  <group name="ALA" type="amino" groupID="1">
\&    <atom atomID="1" atomName=" N  " x="\-19.031" y="16.695" z="3.708" />
\&    <atom atomID="2" atomName=" CA " x="\-20.282" y="16.902" z="4.404" />
\&    <atom atomID="3" atomName=" C  " x="\-20.575" y="18.394" z="4.215" />
\&    <atom atomID="4" atomName=" O  " x="\-20.436" y="19.194" z="5.133" />
\&    <atom atomID="5" atomName=" CB " x="\-20.077" y="16.548" z="5.883" />
\&    <atom atomID="6" atomName="1H  " x="\-18.381" y="17.406" z="4.081" />
\&    <atom atomID="7" atomName="2H  " x="\-18.579" y="15.781" z="3.874" />
\&    <atom atomID="8" atomName="3H  " x="\-19.018" y="16.844" z="2.68" />
\&  </group>
\&  <group name="HOH" type="hetatm" groupID="219">
\&    <atom atomID="3057" atomName=" O  " x="\-17.904" y="13.635" z="\-7.538" />
\&    <atom atomID="3058" atomName="1H  " x="\-18.717" y="14.098" z="\-7.782" />
\&    <atom atomID="3059" atomName="2H  " x="\-17.429" y="13.729" z="\-8.371" />
\&  </group>
\&</chain>
\&<connect atomSerial="26" type="bond">
\&  <atomID atomID="25" />
\&  <atomID atomID="242" />
\&</connect>
.Ve
.SS "_gen_object_response"
.IX Subsection "_gen_object_response"
.Vb 6
\& Title    : _gen_object_response
\& Function : Formats the supplied structure object data structure into dasstructure xml
\& Args     : object data structure
\& Returns  : Das Response string encapuslating \*(Aqobject\*(Aq
\& Comment  : The object response allows the details of the coordinates to be descriped. For example
\&          : the fact that the coos are part of a pdb file.
.Ve
.SS "_gen_chain_response"
.IX Subsection "_gen_chain_response"
.Vb 6
\& Title    : _gen_chain_response
\& Function : Formats the supplied chain object data structure into dasstructure xml
\& Args     : chain data structure
\& Returns  : Das Response string encapuslating \*(Aqchain\*(Aq
\& Comment  : Chain objects contain all of the atom positions (including hetatoms).
\&          : The groups are typically residues or ligands.
.Ve
.SS "_gen_connect_response"
.IX Subsection "_gen_connect_response"
.Vb 5
\& Title    : _gen_connect_response
\& Function : Formats the supplied connect data structure into dasstructure xml
\& Args     : connect data structure
\& Returns  : Das Response string encapuslating "connect"
\& Comment  : Such objects are specified to enable groups of atoms to be connected together.
.Ve
.SS "cleanup : Post-request garbage collection"
.IX Subsection "cleanup : Post-request garbage collection"
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Used within Bio::Das::ProServer::Config, eg/proserver and of course all subclasses.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
set \f(CW$self\fR\->{'debug'} = 1
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.IP "HTML::Entities" 4
.IX Item "HTML::Entities"
.PD 0
.IP "HTTP::Date" 4
.IX Item "HTTP::Date"
.IP "English" 4
.IX Item "English"
.IP "Carp" 4
.IX Item "Carp"
.PD
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
None reported
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2008 The Sanger Institute
.PP
This program is free software: you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
